import Commander
import Foundation

enum CompletionsCommand {
  /// Note: This command intentionally does not use CommandSignatures.withRuntimeFlags()
  /// because --json, --verbose, and --log-level don't make sense for generating
  /// completion scripts. The output is always plain text shell/markdown.
  static let spec = CommandSpec(
    name: "completions",
    abstract: "Generate shell completions or LLM context",
    discussion: "Outputs completion scripts for bash, zsh, fish, or context for LLM assistants.",
    signature: CommandSignature(
      arguments: [
        ArgumentDefinition.make(label: "shell", help: "Shell type: bash, zsh, fish, or llm")
      ]
    ),
    usageExamples: [
      "imsg completions bash > ~/.bash_completion.d/imsg",
      "imsg completions zsh > ~/.zsh/completions/_imsg",
      "imsg completions fish > ~/.config/fish/completions/imsg.fish",
      "imsg completions llm | pbcopy",
    ]
  ) { values, _ in
    try run(shell: values.argument(0))
  }

  static func run(shell: String?) throws {
    let output = try generateOutput(shell: shell)
    Swift.print(output)
  }

  /// Generate completion output without printing (for testing)
  static func generateOutput(shell: String?) throws -> String {
    guard let shell = shell else {
      throw CompletionsError.missingShell
    }
    switch shell.lowercased() {
    case "bash":
      return BashCompletionGenerator.generate()
    case "zsh":
      return ZshCompletionGenerator.generate()
    case "fish":
      return FishCompletionGenerator.generate()
    case "llm":
      return LLMContextGenerator.generate()
    default:
      throw CompletionsError.unknownShell(shell)
    }
  }
}

enum CompletionsError: Error, CustomStringConvertible, Sendable {
  case missingShell
  case unknownShell(String)

  var description: String {
    switch self {
    case .missingShell:
      return "Missing shell argument. Use: bash, zsh, fish, or llm"
    case .unknownShell(let shell):
      return "Unknown shell '\(shell)'. Use: bash, zsh, fish, or llm"
    }
  }
}

// MARK: - Bash

private enum BashCompletionGenerator {
  static func generate() -> String {
    let meta = CompletionMetadata.self
    let commands = meta.commands.map { $0.name }.joined(separator: " ")
    let logLevels = meta.logLevelChoices.joined(separator: " ")
    let services = meta.serviceChoices.joined(separator: " ")

    var commandCases = ""
    for cmd in meta.commands {
      let allOpts = (meta.runtimeOptions + cmd.options).map { "--\($0.long)" }.joined(
        separator: " ")
      commandCases += """
                \(cmd.name))
                    COMPREPLY=($(compgen -W "\(allOpts)" -- "$cur"))
                    ;;

        """
    }

    return """
      # Bash completion for \(meta.cliName)
      # Generated by: \(meta.cliName) completions bash

      _\(meta.cliName)() {
          local cur prev words cword
          _init_completion || return

          local commands="\(commands)"
          local log_levels="\(logLevels)"
          local services="\(services)"

          local cmd=""
          local i
          for ((i=1; i < cword; i++)); do
              case "${words[i]}" in
                  -*)
                      case "${words[i]}" in
                          --db|--log-level) ((i++)) ;;
                      esac
                      ;;
                  *)
                      if [[ " $commands " =~ " ${words[i]} " ]]; then
                          cmd="${words[i]}"
                          break
                      fi
                      ;;
              esac
          done

          case "$prev" in
              --log-level) COMPREPLY=($(compgen -W "$log_levels" -- "$cur")); return ;;
              --service) COMPREPLY=($(compgen -W "$services" -- "$cur")); return ;;
              --db|--file) _filedir; return ;;
          esac

          if [[ -z "$cmd" ]]; then
              if [[ "$cur" == -* ]]; then
                  COMPREPLY=($(compgen -W "--help -h --version -V" -- "$cur"))
              else
                  COMPREPLY=($(compgen -W "$commands" -- "$cur"))
              fi
              return
          fi

          case "$cmd" in
      \(commandCases)    esac
      }

      complete -F _\(meta.cliName) \(meta.cliName)
      """
  }
}

// MARK: - Zsh

private enum ZshCompletionGenerator {
  static func generate() -> String {
    let meta = CompletionMetadata.self

    var commandDescriptions = ""
    for cmd in meta.commands {
      commandDescriptions += "        '\(cmd.name):\(cmd.description)'\n"
    }

    var commandCases = ""
    for cmd in meta.commands {
      var opts = ""
      for opt in meta.runtimeOptions + cmd.options {
        let desc = opt.description.replacingOccurrences(of: "'", with: "\\'")
        if opt.takesValue {
          if let choices = opt.choices {
            opts +=
              "                '--\(opt.long)[\(desc)]:\(opt.long):(\(choices.joined(separator: " ")))'\n"
          } else {
            let hint = opt.valueHint ?? opt.long
            opts += "                '--\(opt.long)[\(desc)]:\(hint)'\n"
          }
        } else {
          if let short = opt.short {
            opts +=
              "                '(-\(short) --\(opt.long))'{-\(short),--\(opt.long)}'[\(desc)]'\n"
          } else {
            opts += "                '--\(opt.long)[\(desc)]'\n"
          }
        }
      }
      commandCases += """
                    \(cmd.name))
                        _arguments \\
        \(opts)                && return 0
                        ;;

        """
    }

    return """
      #compdef \(meta.cliName)
      # Zsh completion for \(meta.cliName)
      # Generated by: \(meta.cliName) completions zsh

      _\(meta.cliName)() {
          local context state state_descr line
          typeset -A opt_args

          local -a commands
          commands=(
      \(commandDescriptions)    )

          _arguments -C \\
              '(- *)'{-h,--help}'[Show help]' \\
              '(- *)'{-V,--version}'[Show version]' \\
              '1: :->command' \\
              '*:: :->args' \\
              && return 0

          case $state in
              command)
                  _describe -t commands '\(meta.cliName) commands' commands
                  ;;
              args)
                  case $words[1] in
      \(commandCases)            esac
                  ;;
          esac
      }

      _\(meta.cliName) "$@"
      """
  }
}

// MARK: - Fish

private enum FishCompletionGenerator {
  static func generate() -> String {
    let meta = CompletionMetadata.self
    var lines: [String] = []

    lines.append("# Fish completion for \(meta.cliName)")
    lines.append("# Generated by: \(meta.cliName) completions fish")
    lines.append("")
    lines.append("complete -c \(meta.cliName) -f")
    lines.append("")

    // Helper functions
    lines.append(
      """
      function __\(meta.cliName)_needs_command
          set -l cmd (commandline -opc)
          test (count $cmd) -eq 1
      end

      function __\(meta.cliName)_using_command
          set -l cmd (commandline -opc)
          test (count $cmd) -gt 1 && contains -- $cmd[2] $argv
      end
      """
    )
    lines.append("")

    // Global options
    lines.append("# Global options")
    lines.append(
      "complete -c \(meta.cliName) -n __\(meta.cliName)_needs_command -s h -l help -d 'Show help'")
    lines.append(
      "complete -c \(meta.cliName) -n __\(meta.cliName)_needs_command -s V -l version -d 'Show version'"
    )
    lines.append("")

    // Commands
    lines.append("# Commands")
    for cmd in meta.commands {
      let desc = cmd.description.replacingOccurrences(of: "'", with: "\\'")
      lines.append(
        "complete -c \(meta.cliName) -n __\(meta.cliName)_needs_command -a \(cmd.name) -d '\(desc)'"
      )
    }
    lines.append("")

    // Runtime options (available for all commands)
    lines.append("# Runtime options")
    for opt in meta.runtimeOptions {
      let desc = opt.description.replacingOccurrences(of: "'", with: "\\'")
      var line = "complete -c \(meta.cliName)"
      if let short = opt.short {
        line += " -s \(short)"
      }
      line += " -l \(opt.long) -d '\(desc)'"
      if let choices = opt.choices {
        line += " -xa '\(choices.joined(separator: " "))'"
      } else if opt.takesValue {
        if opt.valueHint == "file" {
          line += " -r -F"
        } else {
          line += " -x"
        }
      }
      lines.append(line)
    }
    lines.append("")

    // Command-specific options
    for cmd in meta.commands {
      guard !cmd.options.isEmpty else { continue }
      lines.append("# \(cmd.name) options")
      for opt in cmd.options {
        let desc = opt.description.replacingOccurrences(of: "'", with: "\\'")
        var line = "complete -c \(meta.cliName) -n '__\(meta.cliName)_using_command \(cmd.name)'"
        line += " -l \(opt.long) -d '\(desc)'"
        if let choices = opt.choices {
          line += " -xa '\(choices.joined(separator: " "))'"
        } else if opt.takesValue {
          if opt.valueHint == "file" {
            line += " -r -F"
          } else {
            line += " -x"
          }
        }
        lines.append(line)
      }
      lines.append("")
    }

    return lines.joined(separator: "\n")
  }
}

// MARK: - LLM Context

private enum LLMContextGenerator {
  static func generate() -> String {
    let meta = CompletionMetadata.self
    var lines: [String] = []

    lines.append("# \(meta.cliName) CLI Reference")
    lines.append("")
    lines.append(meta.description)
    lines.append("")
    lines.append("## Requirements")
    lines.append("- macOS 14+ with Messages.app signed in")
    lines.append("- Full Disk Access permission for terminal (to read chat.db)")
    lines.append("- Automation permission for Messages.app (for sending)")
    lines.append("")

    lines.append("## Global Options")
    lines.append("```")
    lines.append("-h, --help     Show help")
    lines.append("-V, --version  Show version")
    lines.append("```")
    lines.append("")

    lines.append("## Runtime Options (available on all commands)")
    lines.append("```")
    for opt in meta.runtimeOptions {
      var line = "--\(opt.long)"
      if let short = opt.short {
        line = "-\(short), " + line
      }
      if opt.takesValue {
        line += " <\(opt.valueHint ?? "value")>"
      }
      let padding = String(repeating: " ", count: max(1, 30 - line.count))
      line += padding + opt.description
      if let choices = opt.choices {
        line += " [\(choices.joined(separator: "|"))]"
      }
      lines.append(line)
    }
    lines.append("```")
    lines.append("")

    lines.append("## Commands")
    lines.append("")
    for cmd in meta.commands {
      lines.append("### \(cmd.name)")
      lines.append(cmd.description)
      lines.append("")
      if !cmd.options.isEmpty {
        lines.append("Options:")
        lines.append("```")
        for opt in cmd.options {
          var line = "--\(opt.long)"
          if opt.takesValue {
            line += " <\(opt.valueHint ?? "value")>"
          }
          let padding = String(repeating: " ", count: max(1, 28 - line.count))
          line += padding + opt.description
          if let choices = opt.choices {
            line += " [\(choices.joined(separator: "|"))]"
          }
          lines.append(line)
        }
        lines.append("```")
        lines.append("")
      }
      lines.append("Examples:")
      lines.append("```bash")
      for example in cmd.examples {
        lines.append(example)
      }
      lines.append("```")
      lines.append("")
    }

    lines.append("## JSON Output")
    lines.append("")
    lines.append("Use `--json` flag for machine-readable output (JSON Lines format).")
    lines.append("")
    lines.append("### Chat object")
    lines.append("```json")
    lines.append(
      """
      {"id": 1, "name": "John Doe", "identifier": "+14155551212", "service": "iMessage", "last_message_at": "2025-01-01T12:00:00.000Z"}
      """
    )
    lines.append("```")
    lines.append("")
    lines.append("### Message object")
    lines.append("```json")
    lines.append(
      """
      {"id": 123, "chat_id": 1, "guid": "...", "sender": "+14155551212", "is_from_me": false, "text": "Hello", "created_at": "2025-01-01T12:00:00.000Z", "attachments": [], "reactions": []}
      """
    )
    lines.append("```")
    lines.append("")

    lines.append("## Common Workflows")
    lines.append("")
    lines.append("1. List chats to find chat ID:")
    lines.append("   `imsg chats --limit 10`")
    lines.append("")
    lines.append("2. Get history for a chat:")
    lines.append("   `imsg history --chat-id 1 --limit 20`")
    lines.append("")
    lines.append("3. Watch for new messages:")
    lines.append("   `imsg watch --chat-id 1 --json`")
    lines.append("")
    lines.append("4. Send a message:")
    lines.append("   `imsg send --to +14155551212 --text \"Hello\"`")
    lines.append("")

    return lines.joined(separator: "\n")
  }
}
